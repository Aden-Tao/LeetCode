## 算法1

**(动态规划)*O(n)***

状态表示：f[i] 表示前 i 个数字共有多少种解码方式。<br>
初始化：0个数字解码的方案数1，即 f[0]=1。<br>
状态转移：f[i] 可以表示成如下两部分的和：

* 如果第 i 个数字不是0，则 i 个数字可以单独解码成一个字母，此时的方案数等于用前 i−1 个数字解码的方案数，即 f[i−1]；
* 如果第 i−1 个数字和第 i 个数字组成的两位数在 10 到 26 之间，则可以将这两位数字解码成一个字符，此时的方案数等于用前 i−2 个数字解码的方案数，即 f[i−2]；


```CPP
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> f(n + 1, 0);
        f[0] = 1;
        for (int i = 1; i <= n; i ++)
        {
            if (s[i - 1] != '0')
                f[i] += f[i - 1];
            if (i >= 2)
            {
                int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
                if (t >= 10 && t <= 26)
                    f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
```
